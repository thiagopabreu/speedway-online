{
  "version": 3,
  "sources": ["../src/core/WLRoot.ts", "../src/core/WLVirtualKeyboardRoot.ts", "../src/components/canvas-ui-input-guard.ts", "../src/components/virtual-keyboard-ui-root.ts"],
  "sourcesContent": ["/// <reference path=\"../../types/globals.d.ts\" />\nimport { Root, PointerDriver, DOMKeyboardDriver } from '@rafern/canvas-ui';\nimport type { Widget, RootProperties } from '@rafern/canvas-ui';\nimport { vec3, quat } from 'gl-matrix';\n\n// Drivers shared by all UI roots. For some reason, setting up the drivers here\n// crashes Wonderland Editor. Instead, use WLRoot.pointerDriver/keyboardDriver\nlet canvasUIPointerDriver: PointerDriver | null = null;\nlet canvasUIKeyboardDriver: DOMKeyboardDriver | null = null;\n\n// Mapping for 'cursor' components to canvas-ui pointer IDs. Use\n// WLRoot.pointerIDs or WLRoot.getPointerID(cursor)\nlet canvasUIPointerIDs: Map<object, number> | null = null;\n\n/** Impostor interface for the `cursor` WLE component. */\ninterface CursorComponent {\n    rayHit: WL.RayHit,\n}\n\n/** Impostor interface for the `cursor-target` WLE component. */\ninterface CursorTargetComponent {\n    addUnHoverFunction(callback: (object: WL.Object, cursor: CursorComponent) => void): void,\n    addMoveFunction(callback: (object: WL.Object, cursor: CursorComponent) => void): void,\n    addDownFunction(callback: (object: WL.Object, cursor: CursorComponent) => void): void,\n    addUpFunction(callback: (object: WL.Object, cursor: CursorComponent) => void): void,\n    removeUnHoverFunction(callback: (object: WL.Object, cursor: CursorComponent) => void): void,\n    removeMoveFunction(callback: (object: WL.Object, cursor: CursorComponent) => void): void,\n    removeDownFunction(callback: (object: WL.Object, cursor: CursorComponent) => void): void,\n    removeUpFunction(callback: (object: WL.Object, cursor: CursorComponent) => void): void,\n    destroy(): void,\n}\n\n/** Impostor interface for WL.Materials with a flatTexture property. */\ninterface FlatMaterial extends WL.Material {\n    flatTexture: WL.Texture,\n}\n\n/** Impostor interface for WL.Materials with a diffuseTexture property. */\ninterface DiffuseMaterial extends WL.Material {\n    diffuseTexture: WL.Texture,\n}\n\n/**\n * Optional WLRoot constructor properties.\n *\n * @category Core\n */\nexport interface WLRootProperties extends RootProperties {\n    /**\n     * The amount of world units per canvas pixel. Determines the pixel density\n     * of the mesh. 0.01 by default.\n     */\n    unitsPerPixel?: number,\n    /**\n     * The collision group that this root's collider will belong to. If null,\n     * collider and cursor-target will not be added. 1 by default.\n     */\n    collisionGroup?: number,\n    /**\n     * Register the default pointer driver to this root? If collisionGroup is\n     * null, this is forced to false. true by default.\n     */\n    registerPointerDriver?: boolean,\n    /** Register the default keyboard driver to this root? true by default. */\n    registerKeyboardDriver?: boolean,\n}\n\n/**\n * A canvas-ui Root which automatically manages a mesh and input. For an example\n * on how to use this in a component, see example-components/test-ui-root.js\n * @alias module:WLRoot\n */\nexport class WLRoot extends Root {\n    /**\n     * The shared PointerDriver instance. Getter only. The PointerDriver will\n     * only be created when needed. Used for pointer (mouse & XR controller)\n     * input.\n     * @type {PointerDriver}\n     */\n    static get pointerDriver() {\n        if(canvasUIPointerDriver === null)\n            canvasUIPointerDriver = new PointerDriver();\n\n        return canvasUIPointerDriver;\n    }\n\n    /**\n     * The shared DOMKeyboardDriver instance. Getter only. The DOMKeyboardDriver\n     * will only be created when needed. Used for keyboard input.\n     * @type {DOMKeyboardDriver}\n     */\n    static get keyboardDriver() {\n        if(canvasUIKeyboardDriver === null) {\n            canvasUIKeyboardDriver = new DOMKeyboardDriver();\n            canvasUIKeyboardDriver.bindDOMElem(WL.canvas);\n        }\n\n        return canvasUIKeyboardDriver;\n    }\n\n    /**\n     * A Map mapping each cursor component to a PointerDriver's pointer ID.\n     * @type {Map}\n     */\n    static get pointerIDs() {\n        if(canvasUIPointerIDs === null)\n            canvasUIPointerIDs = new Map();\n\n        return canvasUIPointerIDs;\n    }\n\n    /**\n     * Get the pointer ID assigned to a given cursor component. If the cursor\n     * has no pointer ID assigned, a new pointer ID is registered to the\n     * PointerDriver.\n     * @param cursor The cursor component\n     * @type {number}\n     */\n    static getPointerID(cursor: object) {\n        const map = WLRoot.pointerIDs;\n        let pointer = map.get(cursor);\n        if(typeof pointer === 'undefined') {\n            pointer = WLRoot.pointerDriver.registerPointer();\n            //console.log('New pointer', pointer, 'registered for cursor', cursor);\n            map.set(cursor, pointer);\n        }\n\n        return pointer;\n    }\n\n    unitsPerPixel: number;\n    texture: WL.Texture | null = null;\n    meshObject: WL.Object | null;\n    mesh: WL.Mesh | null = null;\n    meshComponent: WL.MeshComponent | null;\n    materialClone: WL.Material;\n    oldTexSize: [number, number] = [0, 0];\n    collision: WL.CollisionComponent | null = null;\n    cursorTarget: CursorTargetComponent | null = null;\n\n    protected valid = false;\n    private keydownEventListener: ((event: KeyboardEvent) => void) | null = null;\n    private keyupEventListener: ((event: KeyboardEvent) => void) | null = null;\n    private unHoverFunction: ((object: WL.Object, cursor: CursorComponent) => void) | null = null;\n    private moveFunction: ((object: WL.Object, cursor: CursorComponent) => void) | null = null;\n    private downFunction: ((object: WL.Object, cursor: CursorComponent) => void) | null = null;\n    private upFunction: ((object: WL.Object, cursor: CursorComponent) => void) | null = null;\n\n    /**\n     * Create a new WLRoot. Note that the properties object can also contain\n     * optional parameters for the canvas-ui Root constructor, and will be\n     * passed to it.\n     *\n     * If texture bleeding prevention is not specified, then it will be enabled\n     * by default.\n     *\n     * If a pointer style handler is not specified, then a default pointer\n     * style handler that changes the cursor style of the Wonderland Engine\n     * canvas will be used.\n     *\n     * @param wlObject The object where the mesh will be added.\n     * @param material The material to use for this root's mesh. The material will be cloned.\n     * @param child The root's child widget.\n     * @constructor\n     */\n    constructor(wlObject: WL.Object, material: WL.Material, child: Widget, properties?: WLRootProperties) {\n        properties = {\n            pointerStyleHandler: style => { WL.canvas.style.cursor = style },\n            preventBleeding: true,\n            ...properties\n        };\n\n        super(child, properties);\n\n        const collisionGroup = properties.collisionGroup ?? 1;\n        const registerPointerDriver = properties.registerPointerDriver ?? true;\n        const registerKeyboardDriver = properties.registerKeyboardDriver ?? true;\n        this.unitsPerPixel = properties.unitsPerPixel ?? 0.01;\n\n        // Create the child object where the mesh and collider will be put.\n        // Starts inactive since the mesh won't be ready yet\n        this.meshObject = WL.scene.addObject(wlObject);\n        this.meshObject.active = false;\n\n        // Setup drivers\n        if(collisionGroup !== null && registerPointerDriver)\n            this.registerDriver(WLRoot.pointerDriver);\n        if(registerKeyboardDriver)\n            this.registerDriver(WLRoot.keyboardDriver);\n\n        // Setup mesh for rendering in world\n        this.meshComponent = this.meshObject.addComponent('mesh') as WL.MeshComponent;\n\n        // keep clone as a variable instead of accessing it later via\n        // this.meshComponent.material because mesh's material setter wraps the material,\n        // so it can't be reused\n        this.materialClone = material.clone();\n        this.meshComponent.material = this.materialClone;\n        this._setupMesh(1, 0);\n\n        // Setup mouse pointer input\n        if(collisionGroup !== null) {\n            this.collision = this.meshObject.addComponent('collision', {\n                collider: WL.Collider.Box,\n                extents: [1, 1, 0.01],\n                group: 1 << collisionGroup,\n            }) as WL.CollisionComponent;\n\n            // FIXME typescript shenanigans - remove typecasts when fixed official d.ts is available\n            this.cursorTarget = this.meshObject.addComponent('cursor-target') as unknown as CursorTargetComponent;\n\n            const cursorPos = new Float32Array(3);\n            const pos = new Float32Array(3);\n            const rot = new Float32Array(4);\n            const meshObject = (this.meshObject as WL.Object);\n            const getCursorPos = (cursor: CursorComponent): [number, number] => {\n                cursorPos.set(cursor.rayHit.locations[0]);\n                // FIXME typescript shenanigans - remove typecasts when fixed official d.ts is available\n                meshObject.getTranslationWorld(pos as unknown as number[]);\n                vec3.sub(cursorPos, cursorPos, pos);\n                // FIXME typescript shenanigans - remove typecasts when fixed official d.ts is available\n                quat.invert(rot, meshObject.rotationWorld as unknown as Float32Array);\n                vec3.transformQuat(cursorPos, cursorPos, rot);\n                vec3.div(cursorPos, cursorPos, meshObject.scalingWorld);\n\n                return [\n                    Math.min(Math.max((cursorPos[0] + 1) / 2, 0), 1),\n                    Math.min(Math.max(1 - ((cursorPos[1] + 1) / 2), 0), 1),\n                ];\n            }\n\n            if(registerPointerDriver) {\n                let shift = false, ctrl = false, alt = false;\n\n                this.keydownEventListener = (event: KeyboardEvent) => {\n                    if(event.key === 'Shift')\n                        shift = true;\n                    if(event.key === 'Control')\n                        ctrl = true;\n                    if(event.key === 'Alt')\n                        alt = true;\n                };\n\n                this.keyupEventListener = (event: KeyboardEvent) => {\n                    if(event.key === 'Shift')\n                        shift = false;\n                    if(event.key === 'Control')\n                        ctrl = false;\n                    if(event.key === 'Alt')\n                        alt = false;\n                };\n\n                WL.canvas.addEventListener('keydown', this.keydownEventListener);\n                WL.canvas.addEventListener('keyup', this.keyupEventListener);\n\n                this.unHoverFunction = (_: WL.Object, cursor: CursorComponent) => {\n                    WLRoot.pointerDriver.leavePointer(\n                        this, WLRoot.getPointerID(cursor)\n                    );\n                };\n\n                this.moveFunction = (_: WL.Object, cursor: CursorComponent) => {\n                    WLRoot.pointerDriver.movePointer(\n                        this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), null, shift, ctrl, alt\n                    );\n                };\n\n                this.downFunction = (_: WL.Object, cursor: CursorComponent) => {\n                    WLRoot.pointerDriver.movePointer(\n                        this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), 1, shift, ctrl, alt\n                    );\n                };\n\n                this.upFunction = (_: WL.Object, cursor: CursorComponent) => {\n                    WLRoot.pointerDriver.movePointer(\n                        this, WLRoot.getPointerID(cursor), ...getCursorPos(cursor), 0, shift, ctrl, alt\n                    );\n                };\n\n                this.cursorTarget.addUnHoverFunction(this.unHoverFunction);\n                this.cursorTarget.addMoveFunction(this.moveFunction);\n                this.cursorTarget.addDownFunction(this.downFunction);\n                this.cursorTarget.addUpFunction(this.upFunction);\n            }\n        }\n\n        this.valid = true;\n\n        // Wonderland engine has much stricter texture limits because of the\n        // texture atlas system. Limit canvas to 2048x2048 by default\n        this.maxCanvasWidth = 2048;\n        this.maxCanvasHeight = 2048;\n    }\n\n\n    /**\n     * Do a full update of this root. Does a pre-layout update, resolves the\n     * layout, does a post-layout update and paints. Call this instead of the\n     * individual Root update methods.\n     */\n    update() {\n        if(!this.valid)\n            return;\n\n        // We know that this is `valid` and hence not null, typecast\n        const meshObject = (this.meshObject as WL.Object);\n\n        // Update (pre-layout)\n        this.preLayoutUpdate();\n\n        // Resolve layout\n        const layoutDirty = this.resolveLayout();\n        const [canvasWidth, canvasHeight] = this.canvasDimensions;\n        if(layoutDirty) {\n            //console.log('Root\\'s layout was dirty, resizing');\n            // Resize and update UV if layout was dirty so that UI is not\n            // stretched\n            const [width, height] = this.dimensions;\n            const [scaleX, scaleY] = this.effectiveScale;\n            meshObject.resetScaling();\n            meshObject.scale([\n                this.unitsPerPixel * width,\n                this.unitsPerPixel * height,\n                0.01,\n            ]);\n\n            if(this.collision !== null) {\n                this.collision.extents = [\n                    meshObject.scalingWorld[0],\n                    meshObject.scalingWorld[1],\n                    0.01,\n                ];\n            }\n\n            this._setupMesh(scaleX * width / canvasWidth, 1 - (scaleY * height / canvasHeight));\n        }\n\n        // Update (post-layout)\n        this.postLayoutUpdate();\n\n        // Paint\n        const wasDirty = this.paint();\n\n        // Enable child object if the canvas is enabled\n        meshObject.active = this.enabled;\n\n        if(!wasDirty)\n            return;\n\n        // Update texture if needed (if root was dirty)\n        if(this.oldTexSize[0] !== canvasWidth || this.oldTexSize[1] !== canvasHeight) {\n            this.oldTexSize[0] = canvasWidth;\n            this.oldTexSize[1] = canvasHeight;\n            const mat = this.materialClone;\n            const oldTexture = this.texture;\n            this.texture = new WL.Texture(this.canvas);\n            if(mat.shader === 'Flat Opaque Textured' || mat.shader === 'Flat Transparent Textured')\n                (mat as FlatMaterial).flatTexture = this.texture;\n            else if(mat.shader == 'Phong Opaque Textured')\n                (mat as DiffuseMaterial).diffuseTexture = this.texture;\n            else\n                console.error('Shader', mat.shader, 'not supported by WLRoot');\n\n            // Destroy old texture so that there isn't an accumulation of\n            // texture atlas usage over time\n            if(oldTexture)\n                oldTexture.destroy();\n        }\n        else if(this.texture) {\n            //console.log('Root was dirty, updating texture');\n            this.texture.update();\n        }\n        else\n            console.warn('There is no texture to update! Is the canvas dimensionless?');\n    }\n\n    private _setupMesh(u: number, v: number) {\n        const newMesh = new WL.Mesh({\n            indexData: new Uint8Array([\n                0, 3, 1, // top-right triangle\n                0, 2, 3, // bottom-left triangle\n            ]),\n            indexType: WL.MeshIndexType.UnsignedByte,\n            vertexCount: 4,\n        });\n\n        const positions = newMesh.attribute(WL.MeshAttribute.Position);\n        const normals = newMesh.attribute(WL.MeshAttribute.Normal);\n        const texCoords = newMesh.attribute(WL.MeshAttribute.TextureCoordinate);\n\n        // top-left\n        positions.set(0, [-1, 1, 0]);\n          normals.set(0, [0, 0, 1]);\n        texCoords.set(0, [0, 1]);\n        // top-right\n        positions.set(1, [1, 1, 0]);\n          normals.set(1, [0, 0, 1]);\n        texCoords.set(1, [u, 1]);\n        // bottom-left\n        positions.set(2, [-1, -1, 0]);\n          normals.set(2, [0, 0, 1]);\n        texCoords.set(2, [0, v]);\n        // bottom-right\n        positions.set(3, [1, -1, 0]);\n          normals.set(3, [0, 0, 1]);\n        texCoords.set(3, [u, v]);\n\n        (this.meshComponent as WL.MeshComponent).mesh = newMesh;\n\n        if(this.mesh)\n            this.mesh.destroy();\n\n        this.mesh = newMesh;\n    }\n\n    override destroy(): void {\n        // remove listeners\n        if(this.keydownEventListener !== null) {\n            WL.canvas.removeEventListener('keydown', this.keydownEventListener);\n            this.keydownEventListener = null;\n        }\n\n        if(this.keyupEventListener !== null) {\n            WL.canvas.removeEventListener('keyup', this.keyupEventListener);\n            this.keyupEventListener = null;\n        }\n\n        if(this.cursorTarget) {\n            if(this.unHoverFunction !== null) {\n                this.cursorTarget.removeUnHoverFunction(this.unHoverFunction);\n                this.unHoverFunction = null;\n            }\n\n            if(this.moveFunction !== null) {\n                this.cursorTarget.removeMoveFunction(this.moveFunction);\n                this.moveFunction = null;\n            }\n\n            if(this.downFunction !== null) {\n                this.cursorTarget.removeDownFunction(this.downFunction);\n                this.downFunction = null;\n            }\n\n            if(this.upFunction !== null) {\n                this.cursorTarget.removeUpFunction(this.upFunction);\n                this.upFunction = null;\n            }\n        }\n\n        // destroy WLE objects\n        if(this.texture) {\n            this.texture.destroy();\n            this.texture = null;\n        }\n\n        if(this.collision) {\n            this.collision.destroy();\n            this.collision = null;\n        }\n\n        if(this.cursorTarget) {\n            this.cursorTarget.destroy();\n            this.cursorTarget = null;\n        }\n\n        if(this.meshComponent) {\n            this.meshComponent.destroy();\n            this.meshComponent = null;\n        }\n\n        // FIXME material is not destroyed. find a way to do it\n\n        if(this.mesh)\n            this.mesh.destroy();\n\n        if(this.meshObject) {\n            this.meshObject.destroy();\n            this.meshObject = null;\n        }\n\n        this.valid = false;\n        super.destroy();\n    }\n}\n", "/// <reference path=\"../../types/globals.d.ts\" />\nimport { VirtualKeyboard, defaultVirtualKeyboardTemplate, Margin } from '@rafern/canvas-ui';\nimport type { VirtualKeyboardRootProperties, KeyboardDriver } from '@rafern/canvas-ui';\nimport type { WLRootProperties } from './WLRoot';\nimport { WLRoot } from './WLRoot';\n\n/**\n * Optional WLVirtualKeyboardRoot constructor properties.\n *\n * @category Core\n */\nexport interface WLVirtualKeyboardRootProperties extends VirtualKeyboardRootProperties, WLRootProperties {\n    /** The KeyboardDriver to dispatch key events to. If null (default), WLRoot.keyboardDriver is used. */\n    keyboardDriver?: KeyboardDriver,\n}\n\n/**\n * A WLRoot with a virtual keyboard, similar to VirtualKeyboardRoot from\n * canvas-ui. Can also be automatically hidden when there is no keyboard focus\n * by callid updateVisibility before calling update. This doesn't need to be\n * directly used, the virtual-keyboard-ui-root component can be used instead.\n * @alias module:WLVirtualKeyboardRoot\n */\nexport class WLVirtualKeyboardRoot extends WLRoot {\n    /** The {@link KeyboardDriver} used by this root's virtual keyboard. */\n    private readonly keyboardDriver: KeyboardDriver;\n\n    /**\n     * Create a new WLVirtualKeyboardRoot.\n     * @param wlObject The object where the mesh will be added.\n     * @param material The material to use for this root's mesh. The material will be cloned.\n     * @constructor\n     */\n    constructor(wlObject: WL.Object, material: WL.Material, properties?: WLVirtualKeyboardRootProperties) {\n        const keyboardDriver = properties?.keyboardDriver ?? WLRoot.keyboardDriver;\n\n        super(\n            wlObject,\n            material,\n            new Margin(\n                new VirtualKeyboard(\n                    keyboardDriver,\n                    properties?.keyboardTemplate ?? defaultVirtualKeyboardTemplate\n                ),\n            ),\n            properties\n        );\n\n        this.keyboardDriver = keyboardDriver;\n    }\n\n    /**\n     * Automatically enables/disables this root if needed/unneeded. Call this\n     * before calling update.\n     */\n    updateVisibility() {\n        if(!this.valid)\n            return;\n\n        // Update visibility of virtual keyboard\n        this.enabled = this.keyboardDriver.needsInput;\n    }\n}\n", "/// <reference path=\"../../types/globals.d.ts\" />\nimport { PointerHint } from '@rafern/canvas-ui';\nimport { WLRoot } from '../core/WLRoot';\n\ninterface CanvasUIInputGuardComponent {\n    init(): void;\n    start(): void;\n    update(dt: number): void;\n    onDeactivate(): void;\n\n    pointer: number | null;\n    pointerComponent: WL.Component | null;\n    keyboardComponent: WL.Component | null;\n    keyboardObject: WL.Object;\n    pointerObject: WL.Object;\n    cursorObject: WL.Object;\n    keyboardComponentName: string;\n    pointerComponentName: string;\n}\n\nWL.registerComponent('canvas-ui-input-guard', {\n    /** (optional) Name of component to disable if keyboard is in use */\n    keyboardComponentName: {type: WL.Type.String, default: ''},\n    /** (optional) Object containing component to disable if keyboard is in use. Required if keyboardComponentName is set, else, ignored */\n    keyboardObject: {type: WL.Type.Object, default: null},\n    /** (optional) Name of component to disable if pointer is hovering a UI root is in use */\n    pointerComponentName: {type: WL.Type.String, default: ''},\n    /** (optional) Object containing component to disable if pointer is hovering a UI root. Required if pointerComponentName is set, else, ignored */\n    pointerObject: {type: WL.Type.Object, default: null},\n    /** (optional) Object which has a cursor component. Required if pointerObject is set, else, ignored */\n    cursorObject: {type: WL.Type.Object, default:null},\n}, <CanvasUIInputGuardComponent>{\n    init() {\n        this.pointer = null;\n        this.pointerComponent = null;\n        this.keyboardComponent = null;\n    },\n    start() {\n        if(this.keyboardComponentName !== '') {\n            if(this.keyboardObject !== null) {\n                const keyboardComponent = this.keyboardObject.getComponent(this.keyboardComponentName, 0);\n                if(keyboardComponent === null)\n                    console.warn('keyboardObject has no component with name', this.keyboardComponentName);\n                else\n                    this.keyboardComponent = keyboardComponent;\n            }\n            else\n                console.warn('keyboardComponentName set in canvas-ui-keyboard-guard, but keyboardObject was not');\n        }\n\n        if(this.pointerComponentName !== '') {\n            if(this.pointerObject !== null) {\n                const pointerComponent = this.pointerObject.getComponent(this.pointerComponentName, 0);\n                if(pointerComponent === null) {\n                    console.warn('pointerObject has no component with name', this.pointerComponentName);\n                    return;\n                }\n\n                if(this.cursorObject !== null) {\n                    const cursor = this.cursorObject.getComponent('cursor', 0);\n                    if(cursor === null)\n                        console.warn('cursorObject set in canvas-ui-keyboard-guard, but cursorObject has no cursor component');\n                    else {\n                        this.pointer = WLRoot.getPointerID(cursor);\n                        this.pointerComponent = pointerComponent;\n                    }\n                }\n                else\n                    console.warn('pointerObject set in canvas-ui-keyboard-guard, but cursorObject was not');\n            }\n            else\n                console.warn('pointerComponentName set in canvas-ui-keyboard-guard, but pointerObject was not');\n        }\n\n    },\n    update(_dt) {\n        if(this.keyboardComponent !== null) {\n            const enable = !WLRoot.keyboardDriver.needsInput;\n            this.keyboardComponent.active = enable;\n        }\n\n        if(this.pointer !== null && this.pointerComponent !== null) {\n            const enable = (WLRoot.pointerDriver.getPointerHint(this.pointer) === PointerHint.None);\n            this.pointerComponent.active = enable;\n        }\n    },\n    onDeactivate() {\n        if(this.keyboardComponent !== null)\n            this.keyboardComponent.active = true;\n\n        if(this.pointerComponent !== null)\n            this.pointerComponent.active = true;\n    },\n} as unknown as WL.Component);\n", "/// <reference path=\"../../types/globals.d.ts\" />\nimport { WLVirtualKeyboardRoot } from '../core/WLVirtualKeyboardRoot';\n\ninterface VirtualKeyboardUIRootComponent {\n    init(): void;\n    update(dt: number): void;\n    onActivate(): void;\n    onDeactivate(): void;\n\n    root: WLVirtualKeyboardRoot;\n    forceDisabled: boolean;\n    object: WL.Object;\n    material: WL.Material;\n}\n\nWL.registerComponent('virtual-keyboard-ui-root', {\n    /** Material to apply the canvas texture to */\n    material: {type: WL.Type.Material},\n}, <VirtualKeyboardUIRootComponent>{\n    init() {\n        this.root = new WLVirtualKeyboardRoot(this.object, this.material);\n        this.forceDisabled = false;\n    },\n    update(_dt) {\n        if(this.root && !this.forceDisabled) {\n            this.root.updateVisibility();\n            this.root.update();\n        }\n    },\n    onActivate() {\n        if(this.root) {\n            this.forceDisabled = false;\n            this.root.enabled = true;\n        }\n    },\n    onDeactivate() {\n        if(this.root) {\n            this.forceDisabled = true;\n            this.root.enabled = false;\n        }\n    },\n} as unknown as WL.Component);\n"],
  "mappings": "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",
  "names": ["Root", "PointerDriver", "DOMKeyboardDriver", "vec3", "quat", "canvasUIPointerDriver", "canvasUIKeyboardDriver", "canvasUIPointerIDs", "WLRoot", "Root", "wlObject", "material", "child", "properties", "_a", "_b", "_c", "_d", "__spreadValues", "style", "collisionGroup", "registerPointerDriver", "registerKeyboardDriver", "cursorPos", "pos", "rot", "meshObject", "getCursorPos", "cursor", "vec3", "quat", "shift", "ctrl", "alt", "event", "_", "PointerDriver", "DOMKeyboardDriver", "map", "pointer", "layoutDirty", "canvasWidth", "canvasHeight", "width", "height", "scaleX", "scaleY", "wasDirty", "mat", "oldTexture", "u", "v", "newMesh", "positions", "normals", "texCoords", "VirtualKeyboard", "defaultVirtualKeyboardTemplate", "Margin", "WLVirtualKeyboardRoot", "WLRoot", "wlObject", "material", "properties", "_a", "_b", "keyboardDriver", "Margin", "VirtualKeyboard", "defaultVirtualKeyboardTemplate", "PointerHint", "keyboardComponent", "pointerComponent", "cursor", "WLRoot", "_dt", "enable", "PointerHint", "WLVirtualKeyboardRoot", "_dt"]
}
